module.exports = { contents : "import {\n    assign,\n    isArray,\n    isFunction,\n    isInvalid,\n    isNullOrUndef,\n    isStringOrNumber,\n    isUndefined,\n    throwError\n} from '~/packages/inferno-shared/dist-es';\nimport VNodeFlags from 'inferno-vnode-flags';\nimport options from '../core/options';\nimport {\n    cloneVNode,\n    createTextVNode,\n    createVoidVNode\n} from '../core/VNodes';\nimport { svgNS } from './constants';\nimport { mount } from './mounting';\nimport { patch } from './patching';\nimport { componentToDOMNodeMap } from './rendering';\nimport { unmount } from './unmounting';\nexport const EMPTY_OBJ = {};\nif (process.env.NODE_ENV !== 'production') {\n    Object.freeze(EMPTY_OBJ);\n}\nexport function createClassComponentInstance(vNode, Component, props, context, isSVG) {\n    if (isUndefined(context)) {\n        context = EMPTY_OBJ;\n    }\n    const instance = new Component(props, context);\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    instance._patch = patch;\n    if (options.findDOMNodeEnabled) {\n        instance._componentToDOMNodeMap = componentToDOMNodeMap;\n    }\n    instance._unmounted = false;\n    instance._pendingSetState = true;\n    instance._isSVG = isSVG;\n    if (isFunction(instance.componentWillMount)) {\n        instance.componentWillMount();\n    }\n    const childContext = instance.getChildContext();\n    if (isNullOrUndef(childContext)) {\n        instance._childContext = context;\n    } else {\n        instance._childContext = assign({}, context, childContext);\n    }\n    options.beforeRender && options.beforeRender(instance);\n    let input = instance.render(props, instance.state, context);\n    options.afterRender && options.afterRender(instance);\n    if (isArray(input)) {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n        }\n        throwError();\n    } else if (isInvalid(input)) {\n        input = createVoidVNode();\n    } else if (isStringOrNumber(input)) {\n        input = createTextVNode(input, null);\n    } else {\n        if (input.dom) {\n            input = cloneVNode(input);\n        }\n        if (input.flags & VNodeFlags.Component) {\n            input.parentVNode = vNode;\n        }\n    }\n    instance._pendingSetState = false;\n    instance._lastInput = input;\n    return instance;\n}\nexport function replaceLastChildAndUnmount(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling) {\n    replaceVNode(parentDom, mount(nextInput, null, lifecycle, context, isSVG), lastInput, lifecycle, isRecycling);\n}\nexport function replaceVNode(parentDom, dom, vNode, lifecycle, isRecycling) {\n    unmount(vNode, null, lifecycle, false, isRecycling);\n    if (vNode.flags & VNodeFlags.Component) {\n        vNode = vNode.children._lastInput || vNode.children;\n    }\n    replaceChild(parentDom, dom, vNode.dom);\n}\nexport function createFunctionalComponentInput(vNode, component, props, context) {\n    let input = component(props, context);\n    if (isArray(input)) {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n        }\n        throwError();\n    } else if (isInvalid(input)) {\n        input = createVoidVNode();\n    } else if (isStringOrNumber(input)) {\n        input = createTextVNode(input, null);\n    } else {\n        if (input.dom) {\n            input = cloneVNode(input);\n        }\n        if (input.flags & VNodeFlags.Component) {\n            input.parentVNode = vNode;\n        }\n    }\n    return input;\n}\nexport function setTextContent(dom, text) {\n    if (text !== '') {\n        dom.textContent = text;\n    } else {\n        dom.appendChild(document.createTextNode(''));\n    }\n}\nexport function updateTextContent(dom, text) {\n    dom.firstChild.nodeValue = text;\n}\nexport function appendChild(parentDom, dom) {\n    parentDom.appendChild(dom);\n}\nexport function insertOrAppend(parentDom, newNode, nextNode) {\n    if (isNullOrUndef(nextNode)) {\n        appendChild(parentDom, newNode);\n    } else {\n        parentDom.insertBefore(newNode, nextNode);\n    }\n}\nexport function documentCreateElement(tag, isSVG) {\n    if (isSVG === true) {\n        return document.createElementNS(svgNS, tag);\n    } else {\n        return document.createElement(tag);\n    }\n}\nexport function replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    unmount(lastNode, null, lifecycle, false, isRecycling);\n    const dom = mount(nextNode, null, lifecycle, context, isSVG);\n    nextNode.dom = dom;\n    replaceChild(parentDom, dom, lastNode.dom);\n}\nexport function replaceChild(parentDom, nextDom, lastDom) {\n    if (!parentDom) {\n        parentDom = lastDom.parentNode;\n    }\n    parentDom.replaceChild(nextDom, lastDom);\n}\nexport function removeChild(parentDom, dom) {\n    parentDom.removeChild(dom);\n}\nexport function removeAllChildren(dom, children, lifecycle, isRecycling) {\n    dom.textContent = '';\n    if (!options.recyclingEnabled || options.recyclingEnabled && !isRecycling) {\n        removeChildren(null, children, lifecycle, isRecycling);\n    }\n}\nexport function removeChildren(dom, children, lifecycle, isRecycling) {\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        if (!isInvalid(child)) {\n            unmount(child, dom, lifecycle, true, isRecycling);\n        }\n    }\n}\nexport function isKeyed(lastChildren, nextChildren) {\n    return nextChildren.length && !isNullOrUndef(nextChildren[0]) && !isNullOrUndef(nextChildren[0].key) && lastChildren.length && !isNullOrUndef(lastChildren[0]) && !isNullOrUndef(lastChildren[0].key);\n}", 
dependencies : ["~/packages/inferno-shared/dist-es","inferno-vnode-flags","../core/options","../core/VNodes","./constants","./mounting","./patching","./rendering","./unmounting","process"], 
sourceMap : {},
headerContent : ["/* fuse:injection: */ var process = require(\"process\");"], 
mtime : 1488885249000
};