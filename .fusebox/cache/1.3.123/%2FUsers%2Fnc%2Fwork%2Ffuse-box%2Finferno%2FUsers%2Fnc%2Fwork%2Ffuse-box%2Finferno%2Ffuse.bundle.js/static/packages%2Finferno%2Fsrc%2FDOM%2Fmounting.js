module.exports = { contents : "import {\n    isArray,\n    isFunction,\n    isInvalid,\n    isNull,\n    isNullOrUndef,\n    isObject,\n    isStringOrNumber,\n    isUndefined,\n    throwError\n} from '~/packages/inferno-shared/dist-es';\nimport VNodeFlags from 'inferno-vnode-flags';\nimport options from '../core/options';\nimport {\n    cloneVNode,\n    isVNode\n} from '../core/VNodes';\nimport {\n    patchEvent,\n    patchProp\n} from './patching';\nimport {\n    recycleComponent,\n    recycleElement\n} from './recycling';\nimport { componentToDOMNodeMap } from './rendering';\nimport {\n    appendChild,\n    createClassComponentInstance,\n    createFunctionalComponentInput,\n    documentCreateElement,\n    setTextContent,\n    EMPTY_OBJ\n} from './utils';\nimport processElement from './wrappers/processElement';\nexport function mount(vNode, parentDom, lifecycle, context, isSVG) {\n    const flags = vNode.flags;\n    if (flags & VNodeFlags.Element) {\n        return mountElement(vNode, parentDom, lifecycle, context, isSVG);\n    } else if (flags & VNodeFlags.Component) {\n        return mountComponent(vNode, parentDom, lifecycle, context, isSVG, flags & VNodeFlags.ComponentClass);\n    } else if (flags & VNodeFlags.Void) {\n        return mountVoid(vNode, parentDom);\n    } else if (flags & VNodeFlags.Text) {\n        return mountText(vNode, parentDom);\n    } else {\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof vNode === 'object') {\n                throwError(`mount() received an object that's not a valid VNode, you should stringify it first. Object: \"${ JSON.stringify(vNode) }\".`);\n            } else {\n                throwError(`mount() expects a valid VNode, instead it received an object with the type \"${ typeof vNode }\".`);\n            }\n        }\n        throwError();\n    }\n}\nexport function mountText(vNode, parentDom) {\n    const dom = document.createTextNode(vNode.children);\n    vNode.dom = dom;\n    if (parentDom) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nexport function mountVoid(vNode, parentDom) {\n    const dom = document.createTextNode('');\n    vNode.dom = dom;\n    if (parentDom) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nexport function mountElement(vNode, parentDom, lifecycle, context, isSVG) {\n    if (options.recyclingEnabled) {\n        const dom = recycleElement(vNode, lifecycle, context, isSVG);\n        if (!isNull(dom)) {\n            if (!isNull(parentDom)) {\n                appendChild(parentDom, dom);\n            }\n            return dom;\n        }\n    }\n    const flags = vNode.flags;\n    if (isSVG || flags & VNodeFlags.SvgElement) {\n        isSVG = true;\n    }\n    const dom = documentCreateElement(vNode.type, isSVG);\n    const children = vNode.children;\n    const props = vNode.props;\n    const events = vNode.events;\n    const ref = vNode.ref;\n    vNode.dom = dom;\n    if (!isInvalid(children)) {\n        if (isStringOrNumber(children)) {\n            setTextContent(dom, children);\n        } else if (isArray(children)) {\n            mountArrayChildren(children, dom, lifecycle, context, isSVG);\n        } else if (isVNode(children)) {\n            mount(children, dom, lifecycle, context, isSVG);\n        }\n    }\n    let hasControlledValue = false;\n    if (!(flags & VNodeFlags.HtmlElement)) {\n        hasControlledValue = processElement(flags, vNode, dom, true);\n    }\n    if (!isNull(props)) {\n        for (let prop in props) {\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\n        }\n    }\n    if (!isNull(events)) {\n        for (let name in events) {\n            patchEvent(name, null, events[name], dom);\n        }\n    }\n    if (!isNull(ref)) {\n        mountRef(dom, ref, lifecycle);\n    }\n    if (!isNull(parentDom)) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nexport function mountArrayChildren(children, dom, lifecycle, context, isSVG) {\n    for (let i = 0, len = children.length; i < len; i++) {\n        let child = children[i];\n        if (!isInvalid(child)) {\n            if (child.dom) {\n                children[i] = child = cloneVNode(child);\n            }\n            mount(children[i], dom, lifecycle, context, isSVG);\n        }\n    }\n}\nexport function mountComponent(vNode, parentDom, lifecycle, context, isSVG, isClass) {\n    if (options.recyclingEnabled) {\n        const dom = recycleComponent(vNode, lifecycle, context, isSVG);\n        if (!isNull(dom)) {\n            if (!isNull(parentDom)) {\n                appendChild(parentDom, dom);\n            }\n            return dom;\n        }\n    }\n    const type = vNode.type;\n    const props = vNode.props || EMPTY_OBJ;\n    const ref = vNode.ref;\n    let dom;\n    if (isClass) {\n        const instance = createClassComponentInstance(vNode, type, props, context, isSVG);\n        const input = instance._lastInput;\n        instance._vNode = vNode;\n        vNode.dom = dom = mount(input, null, lifecycle, instance._childContext, isSVG);\n        if (!isNull(parentDom)) {\n            appendChild(parentDom, dom);\n        }\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\n        options.findDOMNodeEnabled && componentToDOMNodeMap.set(instance, dom);\n        vNode.children = instance;\n    } else {\n        const input = createFunctionalComponentInput(vNode, type, props, context);\n        vNode.dom = dom = mount(input, null, lifecycle, context, isSVG);\n        vNode.children = input;\n        mountFunctionalComponentCallbacks(ref, dom, lifecycle);\n        if (!isNull(parentDom)) {\n            appendChild(parentDom, dom);\n        }\n    }\n    return dom;\n}\nexport function mountClassComponentCallbacks(vNode, ref, instance, lifecycle) {\n    if (ref) {\n        if (isFunction(ref)) {\n            ref(instance);\n        } else {\n            if (process.env.NODE_ENV !== 'production') {\n                if (isStringOrNumber(ref)) {\n                    throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n                } else if (isObject(ref) && vNode.flags & VNodeFlags.ComponentClass) {\n                    throwError('functional component lifecycle events are not supported on ES2015 class components.');\n                } else {\n                    throwError(`a bad value for \"ref\" was used on component: \"${ JSON.stringify(ref) }\"`);\n                }\n            }\n            throwError();\n        }\n    }\n    const cDM = instance.componentDidMount;\n    const afterMount = options.afterMount;\n    if (!isUndefined(cDM) || !isNull(afterMount)) {\n        lifecycle.addListener(() => {\n            afterMount && afterMount(vNode);\n            cDM && instance.componentDidMount();\n            instance._syncSetState = true;\n        });\n    } else {\n        instance._syncSetState = true;\n    }\n}\nexport function mountFunctionalComponentCallbacks(ref, dom, lifecycle) {\n    if (ref) {\n        if (!isNullOrUndef(ref.onComponentWillMount)) {\n            ref.onComponentWillMount();\n        }\n        if (!isNullOrUndef(ref.onComponentDidMount)) {\n            lifecycle.addListener(() => ref.onComponentDidMount(dom));\n        }\n    }\n}\nexport function mountRef(dom, value, lifecycle) {\n    if (isFunction(value)) {\n        lifecycle.addListener(() => value(dom));\n    } else {\n        if (isInvalid(value)) {\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n        }\n        throwError();\n    }\n}", 
dependencies : ["~/packages/inferno-shared/dist-es","inferno-vnode-flags","../core/options","../core/VNodes","./patching","./recycling","./rendering","./utils","./wrappers/processElement","process"], 
sourceMap : {},
headerContent : ["/* fuse:injection: */ var process = require(\"process\");"], 
mtime : 1488885249000
};